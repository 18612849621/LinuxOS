# 版本日志
- v1.0.0 
  - mbr + loader 
  - 保护模式开启打印字符
- v1.0.1
  - 物理内存容量检测
- v1.0.2
  - 保护模式 + 分页
- v1.0.3
  - 内核加载 由于没初始化idt中断表 所以这一版本通过 cli + sti 关闭中断
- v1.0.4
  - 基础库函数实现
- v1.0.5
  - 基本中断 + 定时器加速


# 资源配置
## 硬盘
hd60.img 磁盘使用(按照最新版本说明)

(512 Bytes per sector)

loader 预留 2 KB 的空间

kernel 预留 100 KB 的空间 

| 磁盘扇区索引 |  内容  |
| :----------: | :----: |
|      0       |  mbr   |
|      1       |        |
|      2       | loader |
|      3       | loader |
|      4       | loader |
|      5       | loader |
|      6       |        |
|      7       |        |
|      8       |        |
|      9       | kernel |
|     ...      |        |
|     208      | kernel |
## 分页
页表(page table) 4 KB

页表项(page table entry) 4 Bytes

一个页表里面有 1024[2^10] 个页表项存储的是物理地址

页表/目录项中仅使用高 20 位表示页表存储的高地址就行 低 12 位就是一些页表特征

为什么只用 20 位表示 因为 32 位计算机有 4GB 的理论空间

4 KB[2^12] 页划分 也就是 2^20 个块就能索引全局

计算第 n (索引从0开始)个表项目的物理地址 (n - 1) * 4

前提：kernel 只使用低端 1 MB 的地址 1 MB / 4 KB = 256 个页面

页表的第 256 项的物理地址 0x1013fc = 0x101000 + (256 - 1) * 4 [0x3fc]

PAGE_DIR_BASE_ADDR_IN_MEM 页表默认地址 0x100000 = 1 MB

此表为标记出符号位(低 12 bit)的值 应该为 0x7 [PAGE_P | PAGE_RW_W | PAGE_US_U]

内核在进程模型中占用高 1GB 空间 3GB~4GB

3G = 11000000_00000000_00000000_00000000 = 0xc0000000

取前 10 位为 1100000000 = 0x300 = 768 (页目录项索引)

所以第 769~1023 页目录项映射到第一个页面

| 地址(low -> high) |   内容   |                    备注                     |
| :---------------: | :------: | :-----------------------------------------: |
|     0x101FFC      |    0     | [第1个页表的最后1项] 1MB以上的空间不会使用  |
|        ...        |    0     |                   未使用                    |
|     0x101400      |    0     |  [第1个页表的第257项]->内核空间的下1个页面  |
|     0x1013FC      | 0x0FF000 | [第1个页表的第256项]->内核空间的最后1个页面 |
|        ...        |   ...    |                     ...                     |
|     0x101004      | 0x001000 |   [第1个页表的第2项]->内核空间的第2个页面   |
|     0x101000      | 0x000000 |   [第1个页表的第1项]->内核空间的第1个页面   |
|     0x100FFC      | 0x100000 |    [最后1个页(1024)目录项]->页目录表本身    |
|     0x100FF8      | 0x1FF000 |       [第1023个页目录项]->第255个页表       |
|        ...        |   ...    |                     ...                     |
|     0x100C04      | 0x102000 |        [第770个页目录项]->第2个页表         |
|     0x100C00      | 0x101000 |        [第769个页目录项]->第1个页表         |
|        ...        |    0     |                   未使用                    |
|     0x100000      | 0x101000 |         [第1个页目录项]->第1个页表          |
|     0x0FFFFF      |   ...    |                内核空间结束                 |
|        ...        |   ...    |                     ...                     |
|     0x000000      |   ...    |                内核空间开始                 |

## 保护模式

即使A20开启，实模式的寻址仍依赖​​16位段寄存器​​和​​16位偏移寄存器​​，计算公式为：

​​物理地址 = 段基址 × 16[左移 4 位] + 偏移量​​

最大地址为 0xFFFF:0xFFFF = 0x10FFEF（约1MB + 64KB - 16B）

所以想要访问全部 4GB 必须依赖保护模式 (初始化选择子 + 打开 PE)

选择子是保护模式的必须机制，遵循就完了

在保护模式下，若A20关闭，第 21 位无论是 0 / 1 都会成为 0 从而导致访问会不连续

## 程序布局

|  地址   |   内容   |               备注               |
| :-----: | :------: | :------------------------------: |
| 0x9FBFF | 可用空间 |     高位可用空间的倒数第一位     |
|   ...   |   ...    |               ...                |
| 0x70000 | 内核文件 |       完整的内核 ELF 文件        |
|   ...   |   ...    |               ...                |
| 0x7E00  | 可用空间 |       高位可用空间的第一位       |
|   ...   |   ...    |               ...                |
| 0x7C00  |   MBR    |                                  |
|   ...   |   ...    |               ...                |
| 0x1500  | 内核程序 | 内核映射 0xc0001500 所使用的空间 |
|   ...   |   ...    |               ...                |
|  0x900  |  LOADER  |                                  |
|   ...   |   ...    |               ...                |
|  0x500  | 可用空间 |       低位可用空间的第一位       |

# boch 调试
## 1.1 start & prepare

```shell
# 需要配置好环境
alias bochsd="bochs -debugger"
bochsd -f bochsrc.conf
```

## 1.2 常用命令

```shell
q 退出
b 添加地址断电
c 持续执行直到断点
trace on 启动汇编内容的打印
trace-reg on 开启寄存器追踪
show int 展示中断
单步执行
s 遇到循环，则进入该命令在单步执行向显存写数据时，显存会刷新，但屏幕显示不会刷新
n 遇到循环，则跳过该命令在单步执行向显存写数据时，显存会刷新，屏幕显示也会刷新
u 反汇编当前内容
```

# 汇编

## 宏

```shell
%macro macro_name number_of_params
    ; 宏体内容
%endmacro
```

## ret & iret

| 特性           | RET                      | IRET                             |
| -------------- | ------------------------ | -------------------------------- |
| **返回类型**   | 子程序调用               | 中断处理                         |
| **堆栈操作**   | 弹出 `IP/EIP`            | 弹出 `IP/EIP`、`CS` 和标志寄存器 |
| **标志寄存器** | 不影响                   | 恢复中断前的标志（如 `IF`）      |
| **特权级切换** | 不支持                   | 可能支持（保护模式下）           |
| **参数调整**   | 支持 `ret n`（清理堆栈） | 不支持                           |

## 栈

|    操作     |            指令步骤            |    栈指针变化    |   数据流向    |
| :---------: | :----------------------------: | :--------------: | :-----------: |
| ​​PUSH src​ | 1. 栈指针减 n 2.数据写入新栈顶 | 减小（向低地址） | src → [SS:SP] |
| ​​POP dst​  | 1. 数据从栈顶读出 2.栈指针加 n | 增大（向高地址） | [SS:SP] → dst |

​​注​​：n 为操作数大小（2或4字节）

# 编译

## gcc

​-fno-builtin 的作用​​：

禁用所有内建函数的替换，强制编译器调用标准库中的实际函数实现，而非编译器的优化版本

## ld

-Text 0xc0001500 指定 .text section 的虚拟地址 说实话写啥都行只会影响符号表布局和实际entry执行的那个程序点的地址，我们只需要通过 -e 绑定好符号也不用关注地址

-e main 指定 main 符号的地址作为程序执行入口地址 

可以通过 nm / readelf 看所有符号的地址

注意这里最好是 main.o 在前面，print.o 在后面 反向link会导致符号的编排顺序发生变化(这句话来自原作者)，但我理解对于我们的程序影响不大

# wiki

## 字符

简单可以使用显示文本模式 80 * 25 为一个屏幕坐标行优先展示

可以打印 2000 个字符 一个字符需要占用 2 Bytes 

所以一共需要 4000 Bytes 

## 字节序

​​优先选择大端​​：
需跨平台通信（网络协议）、强调数据可读性（调试界面）或符号位频繁判断的场景（如嵌入式系统）。

​​优先选择小端​​：
追求硬件效率（科学计算）、需频繁操作低位数据（如加密算法）或运行于 x86/ARM 平台时。

​​跨平台开发必做​​：
使用标准库转换函数（如 htonl()/ntohl()），避免因字节序差异导致数据解析错误